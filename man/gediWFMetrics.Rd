% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/C_processExtractMetrics.R
\name{gediWFMetrics}
\alias{gediWFMetrics}
\title{GEDI full waveform data processing}
\usage{
gediWFMetrics(input, outRoot, writeFit = FALSE, writeGauss = FALSE,
  bounds = NULL, ground = FALSE, useInt = FALSE, useFrac = FALSE,
  rhRes = 5, laiRes = 10, laiH = 30, noRHgauss = FALSE, gTol = 0,
  fhdHistRes = 0.001, forcePsigma = FALSE, bayesGround = FALSE,
  dontTrustGround = FALSE, noRoundCoord = FALSE, noCanopy = FALSE,
  dcBias = 0, nSig = 0, seed = NULL, hNoise = 0,
  linkNoise = NULL, linkFsig = NULL, linkPsig = NULL,
  trueSig = NULL, bitRate = NULL, maxDN = NULL, renoise = FALSE,
  newPsig = -1, oldPsig = 0.764331, addDrift = NULL,
  missGround = FALSE, minGap = NULL, photonCount = FALSE,
  pcl = FALSE, nPhotons = 2.1, photonWind = 200, noiseMult = 0.1,
  rhoVrhoG = 1, nPhotC = 2.1, nPhotG = -1, photHDF = FALSE,
  meanN = 0, thresh = 1e-14, varNoise = FALSE, varScale = NULL,
  statsLen = NULL, noiseTrack = FALSE, sWidth = NULL, psWidth = 0,
  msWidth = NULL, preMatchF = FALSE, postMatchF = FALSE,
  pFile = NULL, gWidth = 1.2, minGsig = 0.764331, minWidth = 0,
  medNoise = FALSE, varDrift = NULL, driftFac = NULL, rhoG = 0.4,
  rhoC = 0.57, pSigma = NULL, gold = FALSE, deconTol = NULL)
}
\arguments{
\item{input}{name. waveform  input filename}

\item{outRoot}{name. output filename root}

\item{writeFit}{write fitted waveform}

\item{writeGauss}{write Gaussian parameters}

\item{bounds}{minX minY maxX maxY. only analyse data within bounds}

\item{ground}{read true ground from file}

\item{useInt}{use discrete intensity instead of count}

\item{useFrac}{use fractional hits rather than counts}

\item{rhRes}{r. percentage energy resolution of RH metrics}

\item{laiRes}{res. lai profile resolution in metres}

\item{laiH}{h. height to calculate LAI to}

\item{noRHgauss}{do not fit Gaussians}

\item{gTol}{tol. ALS ground tolerance. Used to calculate slope.}

\item{fhdHistRes}{res. waveform intensity resolution to use when calculating FHD from histograms}

\item{forcePsigma}{do not read pulse sigma from file}

\item{bayesGround}{use Bayseian ground finding}

\item{dontTrustGround}{don't trust ground in waveforms, if included}

\item{noRoundCoord}{do not round up coords when outputting}

\item{noCanopy}{do not calculate FHD histograms and LAI profiles}

\item{dcBias}{n. mean noise level}

\item{nSig}{sig. noise sigma}

\item{seed}{n. random number seed}

\item{hNoise}{n. hard threshold noise as a fraction of integral}

\item{linkNoise}{linkM cov. apply Gaussian noise based on link margin at a cover}

\item{linkFsig}{sig. footprint width to use when calculating and applying signal noise}

\item{linkPsig}{sig. pulse width to use when calculating and applying signal noise}

\item{trueSig}{sig. true sigma of background noise}

\item{bitRate}{n. digitisation bit rate}

\item{maxDN}{max. maximum DN}

\item{renoise}{remove noise from truth before applying new noise level}

\item{newPsig}{sig. new value for pulse width, when lengthening pulse}

\item{oldPsig}{sig. old value for pulse width if not defined in waveform file, when lengthening pulse}

\item{addDrift}{xi. apply detector background drift}

\item{missGround}{assume ground is missed to assess RH metrics}

\item{minGap}{gap. delete signal beneath min detectable gap fraction}

\item{photonCount}{output point cloud from photon counting}

\item{pcl}{convert to photon counting pulsecompressed}

\item{nPhotons}{n. mean number of photons}

\item{photonWind}{x. window length for photon counting search, metres}

\item{noiseMult}{x. noise multiplier for photoncounting}

\item{rhoVrhoG}{x. ratio of canopy to ground reflectance at this wavelength. Not different from rhoV and rhoG}

\item{nPhotC}{n. mean number of canopy photons (replaces nPhotons and rhoVrhoG)}

\item{nPhotG}{n. mean number of ground photons (replaces nPhotons and rhoVrhoG)}

\item{photHDF}{write photoncounting}

\item{meanN}{n. mean noise level, if using a predefined mean level}

\item{thresh}{n. noise threshold, if using a predefined noise threshold}

\item{varNoise}{use a variable noise threshold}

\item{varScale}{x. variable noise threshold scale (multiple of stdev above mean to set threshold)}

\item{statsLen}{len. length to calculate noise stats over for varNoise}

\item{noiseTrack}{use noise tracking}

\item{sWidth}{sig. smoothing width, after densoising}

\item{psWidth}{sigma. smoothing width, before denoising}

\item{msWidth}{sig. smoothing width, after noise stats, before denoising}

\item{preMatchF}{matched filter before denoising}

\item{postMatchF}{matched filter after denoising}

\item{pFile}{file. read pulse file, for deconvoltuion and matched filters}

\item{gWidth}{sig. Gaussian parameter selection smoothing width}

\item{minGsig}{sig. minimum Gaussian sigma to fit}

\item{minWidth}{n. minimum feature width in bins}

\item{medNoise}{use median stats rather than mean}

\item{varDrift}{correct detector drift with variable factor}

\item{driftFac}{xi. fix drift with constant drift factor}

\item{rhoG}{rho. ground reflectance}

\item{rhoC}{rho. canopy reflectance}

\item{pSigma}{sig. pulse width to smooth by if using Gaussian pulse}

\item{gold}{deconvolve with Gold's method}

\item{deconTol}{deconvolution tolerance}
}
\value{
A S4 object of class \code{\link[hdf5r:H5File-class]{hdf5r::H5File}} in the \emph{hdf5r} package.
}
\description{
GEDI full waveform data processing and metrics extraction
}
\examples{
# specify the path to ALS data
lasfile_amazon <- system.file("extdata", "Amazon.las", package="rGEDI")
lasfile_cerrado <- system.file("extdata", "Cerrado.las", package="rGEDI")
# Reading and plot ALS file
#' 
hasLibraries = require(lidR) && require(plot3D)
if (hasLibraries) {

las_amazon<-readLAS(lasfile_amazon)
las_cerrado<-readLAS(lasfile_cerrado)

# Extracting plot center geolocations
xcenter_amazon = mean(las_amazon@bbox[1,])
ycenter_amazon = mean(las_amazon@bbox[2,])
xcenter_cerrado = mean(las_cerrado@bbox[1,])
ycenter_cerrado = mean(las_cerrado@bbox[2,])

# Simulating GEDI full-waveform
wf_amazon<-gediWFSimulator(
                          input=lasfile_amazon,
                          output=paste0(getwd(),"//gediWF_amazon_simulation.h5"),
                          coords = c(xcenter_amazon, ycenter_amazon))
wf_cerrado<-gediWFSimulator(input=lasfile_cerrado,
                           output=paste0(getwd(),"//gediWF_cerrado_simulation.h5"),
                           coords = c(xcenter_cerrado, ycenter_cerrado))

# Extracting GEDI feull-waveform derived metrics
wf_amazon_metrics<-gediWFMetrics(input=wf_amazon@h5$filename,outRoot=getwd())
wf_cerrado_metrics<-gediWFMetrics(input=wf_cerrado@h5$filename,outRoot=getwd())

metrics<-rbind(wf_amazon_metrics,wf_cerrado_metrics)
rownames(metrics)<-c("Amazon","Cerrado")
head(metrics)
}

}
\seealso{
i) Hancock, S., Armston, J., Hofton, M., Sun, X., Tang, H., Duncanson, L.I., Kellner,
J.R. and Dubayah, R., 2019. The GEDI simulator: A largeâ€footprint waveform lidar simulator
for calibration and validation of spaceborne missions. Earth and Space Science.
https://doi.org/10.1029/2018EA000506

ii) gediSimulator: https://bitbucket.org/StevenHancock/gedisimulator/src/master/
}
